import boto3
import json
from botocore.exceptions import ClientError
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa

def generate_key_pair():
    # Generate RSA private key
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048
    )

    # Generate public key
    public_key = private_key.public_key()

    # Serialize private key to PEM format
    private_key_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption()
    )

    # Serialize public key to PEM format
    public_key_pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )

    return private_key_pem, public_key_pem

def upload_private_key_to_secrets_manager(secret_name, private_key_pem, region_name='us-east-1'):
    client = boto3.client('secretsmanager', region_name=region_name)

    secret_string = {
        'private_key': private_key_pem.decode('utf-8')
    }

    try:
        response = client.create_secret(
            Name=secret_name,
            SecretString=json.dumps(secret_string),
            Description="RSA private key for signing CloudFront URLs"
        )
        print("Secret created successfully:", response)
    except ClientError as e:
        # Handle the exception if the secret already exists or other errors occur
        if e.response['Error']['Code'] == 'ResourceExistsException':
            # Update the existing secret
            response = client.update_secret(
                SecretId=secret_name,
                SecretString=json.dumps(secret_string)
            )
            print("Secret updated successfully:", response)
        else:
            print("Error:", e)

def update_cloudfront_public_key(public_key_pem, cloudfront_distribution_id, region_name='us-east-1'):
    client = boto3.client('cloudfront', region_name=region_name)

    # Get the current CloudFront distribution configuration
    response = client.get_distribution_config(Id=cloudfront_distribution_id)
    distribution_config = response['DistributionConfig']
    etag = response['ETag']

    # Update the public key in the distribution configuration
    distribution_config['ViewerCertificate'] = {
        'CloudFrontDefaultCertificate': False,
        'ACMCertificateArn': '',  # Replace with your ACM certificate ARN if needed
        'SSLSupportMethod': 'sni-only',
        'MinimumProtocolVersion': 'TLSv1.2_2021',
        'IAMCertificateId': '',  # This can be left empty if not using IAM certificates
        'CertificateSource': 'cloudfront',
        'PublicKeyId': 'your-public-key-id'  # This should be replaced with the actual public key ID
    }

    # Update the CloudFront distribution
    response = client.update_distribution(
        DistributionConfig=distribution_config,
        Id=cloudfront_distribution_id,
        IfMatch=etag
    )
    print("CloudFront distribution updated successfully:", response)

if __name__ == '__main__':
    secret_name = 'cloudfront-rsa-private-key'
    cloudfront_distribution_id = 'your-cloudfront-distribution-id'

    # Generate key pair
    private_key_pem, public_key_pem = generate_key_pair()

    # Upload private key to Secrets Manager
    upload_private_key_to_secrets_manager(secret_name, private_key_pem)

    # Update CloudFront with the public key
    update_cloudfront_public_key(public_key_pem, cloudfront_distribution_id)
